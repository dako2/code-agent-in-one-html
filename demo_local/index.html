<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Code Companion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/loader.min.js"></script>
    <script type="module">
        import { GoogleGenAI, Type } from "https://esm.run/@google/genai";
        window.GoogleGenAI = GoogleGenAI;
        window.GeminiType = Type;
    </script>
    <style>
        body {
            background-color: #0D1117;
            color: #C9D1D9;
            font-family: 'SF Mono', 'Consolas', 'Menlo', monospace;
            overflow: hidden;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0D1117; }
        ::-webkit-scrollbar-thumb { background: #2f81f780; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #2f81f7; }
        .glowing-border { box-shadow: 0 0 5px #2f81f7, 0 0 10px #2f81f7, 0 0 15px #2f81f7; }
    </style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef, StrictMode, Fragment } = React;
        const { createRoot } = ReactDOM;
        const { GoogleGenAI, GeminiType } = window;

        // Lightweight LlamaIndex-like Memory (extended: static, facts, vector-like retrieval)
        class LIMemory {
        constructor(options = {}) {
            this.messages = [];
            this.tokenLimit = options.tokenLimit || 12000; // rough char-based limit
            this.shortTermRatio = options.shortTermTokenLimitRatio || 0.7;

            // Long-term blocks
            this.staticBlocks = Array.isArray(options.staticBlocks) ? options.staticBlocks : [];
            this.maxFacts = options.maxFacts || 50;
            this.facts = [];

            // Vector-ish retrieval
            this.enableVector = options.enableVector !== false;
            this.vectorDocs = []; // { id, text }

            // NEW: situational working set (UI context)
            this.working = {
            activePath: null,     // e.g. 'src/components/App.tsx'
            activeFolder: '/',    // e.g. 'src/components'
            selection: ''         // current selected text in editor (latest known)
            };
        }

        // --- helpers ---
        static _normalize(text) {
            return (text || '')
            .toLowerCase()
            .replace(/[^a-z0-9\s_\-\.]/g, ' ')
            .split(/\s+/)
            .filter(Boolean);
        }

        _vectorAdd(text) {
            if (!this.enableVector) return;
            const id = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
            this.vectorDocs.push({ id, text: text || '' });
            if (this.vectorDocs.length > 500) this.vectorDocs.shift();
        }

        _vectorSearch(query, topK = 3) {
            if (!this.enableVector || !query) return [];
            const qTokens = LIMemory._normalize(query);
            if (qTokens.length === 0) return [];
            const scores = this.vectorDocs.map(doc => {
            const dTokens = LIMemory._normalize(doc.text);
            const setD = new Set(dTokens);
            let score = 0;
            for (const t of qTokens) if (setD.has(t)) score += 1;
            return { id: doc.id, text: doc.text, score };
            });
            return scores
            .filter(s => s.score > 0)
            .sort((a, b) => b.score - a.score)
            .slice(0, topK);
        }

        _extractFacts(fromText) {
            const text = fromText || '';
            const sentences = text.split(/(?<=[\.\?!])\s+/);
            for (const s of sentences) {
            if (/\b(is|are|was|were|has|have|uses)\b/i.test(s) && s.length <= 200) {
                this.facts.push(s.trim());
                if (this.facts.length > this.maxFacts) this.facts.shift();
            }
            }
        }

        // --- NEW: working set API ---
        setWorking(partial = {}) {
            // sanitize selection length to avoid blowing the prompt
            const MAX_SEL = 1200; // chars
            const next = { ...this.working, ...partial };
            if (typeof next.selection === 'string' && next.selection.length > MAX_SEL) {
            next.selection = next.selection.slice(0, MAX_SEL) + '\n…[truncated]';
            }
            this.working = next;
        }

        getWorking() {
            return { ...this.working };
        }

        // --- message API ---
        add(message) {
            // message: { role: 'user'|'assistant'|'system', content: string }
            if (!message?.role) return;
            const parts = [{ text: message.content ?? '' }];
            const role = message.role === 'assistant' ? 'model' : message.role;
            this.messages.push({ role, parts });

            // update LT memory blocks
            if (role === 'model') {
            const text = message.content || '';
            this._extractFacts(text);
            this._vectorAdd(text);
            } else if (role === 'user') {
            this._vectorAdd(message.content || '');
            }
        }

        get() { return [...this.messages]; }

        // Build the LLM context with working set first
        getLLM({ tokenLimit } = {}) {
            const limit = tokenLimit || this.tokenLimit;
            const assembled = [];

            // (0) situational working context FIRST
            const w = this.getWorking();
            const workingBlock =
            `Working context:\n` +
            `- activePath: ${w.activePath || '(none)'}\n` +
            `- activeFolder: ${w.activeFolder || '/'}\n` +
            (w.selection
                ? `- selection: |\n${w.selection}\n`
                : `- selection: (none)\n`);
            assembled.push({ role: 'user', parts: [{ text: workingBlock }] });

            // (1) static blocks (immutable instructions)
            if (this.staticBlocks.length) {
            assembled.push({ role: 'user', parts: [{ text: this.staticBlocks.join('\n') }] });
            }

            // (2) vector-retrieved context based on last user message
            const lastUser = [...this.messages].reverse().find(m => m.role === 'user');
            const query = lastUser?.parts?.map(p => p.text || '').join('') || '';
            const vec = this._vectorSearch(query, 3);
            if (vec.length) {
            assembled.push({
                role: 'user',
                parts: [{ text: 'Relevant context:\n' + vec.map(v => `- ${v.text}`).join('\n') }]
            });
            }

            // (3) known facts
            if (this.facts.length) {
            assembled.push({
                role: 'user',
                parts: [{ text: 'Known facts:\n' + this.facts.map(f => `- ${f}`).join('\n') }]
            });
            }

            // (4) short-term history within remaining budget
            let used = assembled.reduce(
            (n, m) => n + (m.parts?.map(p => p.text || '').join('').length || 0),
            0
            );
            const remaining = Math.max(1000, limit - used); // keep at least a small budget
            let total = 0;
            const acc = [];
            for (let i = this.messages.length - 1; i >= 0; i--) {
            const m = this.messages[i];
            const text = (m.parts?.map(p => p.text || '').join('')) || '';
            total += text.length;
            if (total > remaining) break;
            acc.push(m);
            }
            acc.reverse().forEach(m => assembled.push(m));

            return assembled;
        }

        snapshot() {
            try {
            return JSON.stringify({
                messages: this.messages,
                staticBlocks: this.staticBlocks,
                facts: this.facts,
                vectorDocs: this.vectorDocs,
                tokenLimit: this.tokenLimit,
                shortTermRatio: this.shortTermRatio,
                maxFacts: this.maxFacts,
                enableVector: this.enableVector,
                working: this.working               // <-- persist working set
            });
            } catch { return '[]'; }
        }

        load(snapshot) {
            try {
            const obj = JSON.parse(snapshot || '{}');
            if (obj && typeof obj === 'object') {
                this.messages = Array.isArray(obj.messages) ? obj.messages : [];
                this.staticBlocks = Array.isArray(obj.staticBlocks) ? obj.staticBlocks : [];
                this.facts = Array.isArray(obj.facts) ? obj.facts : [];
                this.vectorDocs = Array.isArray(obj.vectorDocs) ? obj.vectorDocs : [];
                this.tokenLimit = obj.tokenLimit || this.tokenLimit;
                this.shortTermRatio = obj.shortTermRatio || this.shortTermRatio;
                this.maxFacts = obj.maxFacts || this.maxFacts;
                this.enableVector = obj.enableVector !== false;
                if (obj.working && typeof obj.working === 'object') {
                this.working = { ...this.working, ...obj.working };
                }
            }
            } catch {}
        }

        clear() {
            this.messages = [];
            this.facts = [];
            this.vectorDocs = [];
            this.working = { activePath: null, activeFolder: '/', selection: '' };
        }
        }

        //     // --- API ---
        //     add(message) {
        //         // message: { role: 'user'|'assistant'|'system', content: string }
        //         if (!message?.role) return;
        //         const parts = [{ text: message.content ?? '' }];
        //         const role = message.role === 'assistant' ? 'model' : message.role;
        //         this.messages.push({ role, parts });
        //         // update LT memory blocks
        //         if (role === 'model') {
        //             const text = message.content || '';
        //             this._extractFacts(text);
        //             this._vectorAdd(text);
        //         } else if (role === 'user') {
        //             this._vectorAdd(message.content || '');
        //         }
        //     }
        //     get() { return [...this.messages]; }
        //     getLLM({ tokenLimit } = {}) {
        //         const limit = tokenLimit || this.tokenLimit;
        //         const assembled = [];
        //         // 1) static
        //         if (this.staticBlocks.length) {
        //             assembled.push({ role: 'user', parts: [{ text: this.staticBlocks.join('\n') }] });
        //         }
        //         // 2) vector-retrieved context based on last user message
        //         const lastUser = [...this.messages].reverse().find(m => m.role === 'user');
        //         const query = lastUser?.parts?.map(p => p.text || '').join('') || '';
        //         const vec = this._vectorSearch(query, 3);
        //         if (vec.length) {
        //             assembled.push({ role: 'user', parts: [{ text: 'Relevant context:\n' + vec.map(v => `- ${v.text}`).join('\n') }] });
        //         }
        //         // 3) extracted facts (summarized list)
        //         if (this.facts.length) {
        //             assembled.push({ role: 'user', parts: [{ text: 'Known facts:\n' + this.facts.map(f => `- ${f}`).join('\n') }] });
        //         }
        //         // 4) short-term history capped to remaining budget
        //         let used = assembled.reduce((n, m) => n + (m.parts?.map(p => p.text || '').join('').length || 0), 0);
        //         const remaining = Math.max(1000, limit - used); // keep at least small budget
        //         let total = 0;
        //         const acc = [];
        //         for (let i = this.messages.length - 1; i >= 0; i--) {
        //             const m = this.messages[i];
        //             const text = (m.parts?.map(p => p.text || '').join('')) || '';
        //             total += text.length;
        //             if (total > remaining) break;
        //             acc.push(m);
        //         }
        //         acc.reverse().forEach(m => assembled.push(m));
        //         return assembled;
        //     }
        //     snapshot() {
        //         try {
        //             return JSON.stringify({
        //                 messages: this.messages,
        //                 staticBlocks: this.staticBlocks,
        //                 facts: this.facts,
        //                 vectorDocs: this.vectorDocs,
        //                 tokenLimit: this.tokenLimit,
        //                 shortTermRatio: this.shortTermRatio,
        //                 maxFacts: this.maxFacts,
        //                 enableVector: this.enableVector
        //             });
        //         } catch { return '[]'; }
        //     }
        //     load(snapshot) {
        //         try {
        //             const obj = JSON.parse(snapshot || '{}');
        //             if (obj && typeof obj === 'object') {
        //                 this.messages = Array.isArray(obj.messages) ? obj.messages : [];
        //                 this.staticBlocks = Array.isArray(obj.staticBlocks) ? obj.staticBlocks : [];
        //                 this.facts = Array.isArray(obj.facts) ? obj.facts : [];
        //                 this.vectorDocs = Array.isArray(obj.vectorDocs) ? obj.vectorDocs : [];
        //                 this.tokenLimit = obj.tokenLimit || this.tokenLimit;
        //                 this.shortTermRatio = obj.shortTermRatio || this.shortTermRatio;
        //                 this.maxFacts = obj.maxFacts || this.maxFacts;
        //                 this.enableVector = obj.enableVector !== false;
        //             }
        //         } catch {}
        //     }
        //     clear() { this.messages = []; this.facts = []; this.vectorDocs = []; }
        // }

        // --- MOCK FILE SYSTEM API ---
        const initialFileSystem = {};

        // --- IndexedDB for remembering the last directory handle ---
        const DB_NAME = 'editor-db', STORE = 'handles', KEY = 'dir';
        const idbOpen = () => new Promise((res, rej) => {
            const r = indexedDB.open(DB_NAME, 1);
            r.onupgradeneeded = () => r.result.createObjectStore(STORE);
            r.onsuccess = () => res(r.result);
            r.onerror = () => rej(r.error);
        });
        const saveHandle = async (handle) => {
            const db = await idbOpen();
            await new Promise((res, rej) => {
                const tx = db.transaction(STORE, 'readwrite');
                tx.objectStore(STORE).put(handle, KEY);
                tx.oncomplete = res; tx.onerror = () => rej(tx.error);
            });
        };
        const loadHandle = async () => {
            const db = await idbOpen();
            return await new Promise((res, rej) => {
                const tx = db.transaction(STORE, 'readonly');
                const req = tx.objectStore(STORE).get(KEY);
                req.onsuccess = () => res(req.result || null);
                req.onerror = () => rej(req.error);
            });
        };

        // --- LOCAL FILE SYSTEM ACCESS API ---
        class LocalFileSystem {
            constructor() {
                this.directoryHandle = null;
                this.isLocalMode = false;
            }

            async openDirectory() {
                try {
                    if (!window.showDirectoryPicker) {
                        throw new Error('File System Access API is not supported in this browser. Please use Chrome, Edge, or Opera.');
                    }
                    
                    // Try to load the last directory handle as a hint
                    const lastHandle = await loadHandle();
                    this.directoryHandle = await window.showDirectoryPicker({
                        id: 'my-editor-root',
                        startIn: lastHandle || 'documents',
                        mode: 'readwrite'
                    });
                    this.isLocalMode = true;
                    
                    // Save the handle for next time
                    await saveHandle(this.directoryHandle);
                    
                    return { success: true, message: `Opened directory: ${this.directoryHandle.name}` };
                } catch (error) {
                    if (error.name === 'AbortError') {
                        return { success: false, message: 'Directory selection cancelled' };
                    }
                    return { success: false, message: `Failed to open directory: ${error.message}` };
                }
            }

            async loadDirectoryStructure() {
                if (!this.directoryHandle) {
                    return { success: false, message: 'No directory selected' };
                }

                try {
                    const structure = await this._loadDirectory(this.directoryHandle);
                    return { success: true, data: structure };
                } catch (error) {
                    return { success: false, message: `Failed to load directory: ${error.message}` };
                }
            }

            async _loadDirectory(dirHandle, path = '') {
                const result = {};
                
                for await (const [name, handle] of dirHandle.entries()) {
                    // Skip hidden files and system files
                    if (name.startsWith('.')) continue;
                    
                    if (handle.kind === 'file') {
                        try {
                            const file = await handle.getFile();
                            const content = await file.text();
                            result[name] = content;
                        } catch (error) {
                            // Skip files that can't be read as text
                            result[name] = `[Binary file - ${name}]`;
                        }
                    } else if (handle.kind === 'directory') {
                        result[name] = await this._loadDirectory(handle, `${path}/${name}`);
                    }
                }
                
                return result;
            }

            async readFile(filePath) {
                if (!this.directoryHandle) {
                    return { success: false, message: 'No directory selected' };
                }

                try {
                    const pathParts = filePath.split('/').filter(p => p);
                    let currentHandle = this.directoryHandle;
                    
                    // Navigate to the file's directory
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
                    }
                    
                    const fileName = pathParts[pathParts.length - 1];
                    const fileHandle = await currentHandle.getFileHandle(fileName);
                    const file = await fileHandle.getFile();
                    const content = await file.text();
                    
                    return { success: true, data: content };
                } catch (error) {
                    return { success: false, message: `Failed to read file: ${error.message}` };
                }
            }

            async writeFile(filePath, content) {
                if (!this.directoryHandle) {
                    return { success: false, message: 'No directory selected' };
                }

                try {
                    const pathParts = filePath.split('/').filter(p => p);
                    let currentHandle = this.directoryHandle;
                    
                    // Navigate to the file's directory, creating directories as needed
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        try {
                            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
                        } catch (error) {
                            // Directory doesn't exist, create it
                            currentHandle = await currentHandle.getDirectoryHandle(pathParts[i], { create: true });
                        }
                    }
                    
                    const fileName = pathParts[pathParts.length - 1];
                    const fileHandle = await currentHandle.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    
                    return { success: true, message: `File saved: ${filePath}` };
                } catch (error) {
                    return { success: false, message: `Failed to write file: ${error.message}` };
                }
            }

            async createFile(filePath, content = '') {
                return await this.writeFile(filePath, content);
            }

            async createDirectory(dirPath) {
                if (!this.directoryHandle) {
                    return { success: false, message: 'No directory selected' };
                }

                try {
                    const pathParts = dirPath.split('/').filter(p => p);
                    let currentHandle = this.directoryHandle;
                    
                    for (const part of pathParts) {
                        try {
                            currentHandle = await currentHandle.getDirectoryHandle(part);
                        } catch (error) {
                            currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
                        }
                    }
                    
                    return { success: true, message: `Directory created: ${dirPath}` };
                } catch (error) {
                    return { success: false, message: `Failed to create directory: ${error.message}` };
                }
            }

            async deleteFile(filePath) {
                if (!this.directoryHandle) {
                    return { success: false, message: 'No directory selected' };
                }

                try {
                    const pathParts = filePath.split('/').filter(p => p);
                    let currentHandle = this.directoryHandle;
                    
                    // Navigate to the file's directory
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
                    }
                    
                    const fileName = pathParts[pathParts.length - 1];
                    await currentHandle.removeEntry(fileName);
                    
                    return { success: true, message: `File deleted: ${filePath}` };
                } catch (error) {
                    return { success: false, message: `Failed to delete file: ${error.message}` };
                }
            }

            async deleteDirectory(dirPath) {
                if (!this.directoryHandle) {
                    return { success: false, message: 'No directory selected' };
                }

                try {
                    const pathParts = dirPath.split('/').filter(p => p);
                    let currentHandle = this.directoryHandle;
                    
                    // Navigate to the parent directory
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        currentHandle = await currentHandle.getDirectoryHandle(pathParts[i]);
                    }
                    
                    const dirName = pathParts[pathParts.length - 1];
                    await currentHandle.removeEntry(dirName, { recursive: true });
                    
                    return { success: true, message: `Directory deleted: ${dirPath}` };
                } catch (error) {
                    return { success: false, message: `Failed to delete directory: ${error.message}` };
                }
            }

            reset() {
                this.directoryHandle = null;
                this.isLocalMode = false;
            }

            isLocalFile(filePath) {
                return this.isLocalMode && !filePath.startsWith('/');
            }
        }

        const localFS = new LocalFileSystem();

        // --- VIRTUAL MIRROR SYSTEM ---
        class VirtualMirror {
            constructor() {
                this.mirror = {};
                this.localToVirtual = new Map(); // Maps local paths to virtual paths
                this.virtualToLocal = new Map(); // Maps virtual paths to local paths
                this.changeHistory = [];
                this.isMirroring = false;
            }

            // Create a virtual mirror of the local directory structure
            async createMirror(localStructure, basePath = '') {
                this.mirror = {};
                this.localToVirtual.clear();
                this.virtualToLocal.clear();
                this.isMirroring = true;
                
                await this._mirrorDirectory(localStructure, basePath, '');
                return { success: true, message: 'Virtual mirror created successfully' };
            }

            async _mirrorDirectory(localStructure, localPath, virtualPath) {
                for (const [name, content] of Object.entries(localStructure)) {
                    const currentLocalPath = localPath ? `${localPath}/${name}` : name;
                    const currentVirtualPath = virtualPath ? `${virtualPath}/${name}` : name;
                    
                    // Map paths bidirectionally
                    this.localToVirtual.set(currentLocalPath, currentVirtualPath);
                    this.virtualToLocal.set(currentVirtualPath, currentLocalPath);
                    
                    if (typeof content === 'object' && content !== null) {
                        // It's a directory
                        if (!this.mirror[currentVirtualPath]) {
                            this.mirror[currentVirtualPath] = {};
                        }
                        await this._mirrorDirectory(content, currentLocalPath, currentVirtualPath);
                    } else {
                        // It's a file
                        this.mirror[currentVirtualPath] = content;
                    }
                }
            }

            // Sync changes from virtual to local
            async syncToLocal() {
                if (!this.isMirroring) return { success: false, message: 'No mirror active' };
                
                const changes = [];
                for (const [virtualPath, content] of Object.entries(this.mirror)) {
                    if (typeof content === 'string') { // It's a file
                        const localPath = this.virtualToLocal.get(virtualPath);
                        if (localPath) {
                            try {
                                const result = await localFS.writeFile(localPath, content);
                                if (result.success) {
                                    changes.push({ type: 'write', path: localPath, content });
                                }
                            } catch (error) {
                                console.error(`Failed to sync ${localPath}:`, error);
                            }
                        }
                    }
                }
                
                this.changeHistory.push({
                    timestamp: Date.now(),
                    type: 'sync_to_local',
                    changes: changes
                });
                
                return { success: true, message: `Synced ${changes.length} files to local`, changes };
            }

            // Sync changes from local to virtual
            async syncFromLocal() {
                if (!this.isMirroring) return { success: false, message: 'No mirror active' };
                
                const structureResult = await localFS.loadDirectoryStructure();
                if (structureResult.success) {
                    await this.createMirror(structureResult.data);
                    return { success: true, message: 'Synced from local to virtual' };
                }
                return { success: false, message: 'Failed to load local structure' };
            }

            // Get virtual file content
            getVirtualFile(virtualPath) {
                return this.mirror[virtualPath] || null;
            }

            // Set virtual file content
            setVirtualFile(virtualPath, content) {
                this.mirror[virtualPath] = content;
                this.changeHistory.push({
                    timestamp: Date.now(),
                    type: 'virtual_change',
                    path: virtualPath,
                    content: content
                });
            }

            // Get change history
            getChangeHistory() {
                return this.changeHistory;
            }

            // Reset mirror
            reset() {
                this.mirror = {};
                this.localToVirtual.clear();
                this.virtualToLocal.clear();
                this.changeHistory = [];
                this.isMirroring = false;
            }

            // Get virtual structure
            getVirtualStructure() {
                return this.mirror;
            }
        }

        const virtualMirror = new VirtualMirror();

        class FileSystem {
            constructor() {
                this.fs = this.loadFromLocalStorage();
            }

            loadFromLocalStorage() {
                try {
                    const savedFs = localStorage.getItem('ai_code_fs');
                    if (savedFs) {
                        return JSON.parse(savedFs);
                    }
                } catch (error) {
                    console.error("Failed to load filesystem from localStorage", error);
                }
                return JSON.parse(JSON.stringify(initialFileSystem));
            }

            saveToLocalStorage() {
                try {
                    localStorage.setItem('ai_code_fs', JSON.stringify(this.fs));
                } catch (error) {
                    console.error("Failed to save filesystem to localStorage", error);
                }
            }
            
            reset() {
                this.fs = JSON.parse(JSON.stringify(initialFileSystem));
                this.saveToLocalStorage();
            }
            
            _resolvePath(path, createMissing = false) {
                const parts = path.split('/').filter(p => p);
                let current = this.fs;
                for (let i = 0; i < parts.length - 1; i++) {
                    const part = parts[i];
                    if (typeof current[part] !== 'object' || current[part] === null) {
                        if (createMissing) {
                            current[part] = {};
                        } else {
                            return null;
                        }
                    }
                    current = current[part];
                }
                return { parent: current, key: parts[parts.length - 1] };
            }

            list(path) {
                const parts = path.split('/').filter(p => p);
                let current = this.fs;
                if (path !== '/' && path !== '') {
                   for (const part of parts) {
                        if (typeof current[part] !== 'object' || current[part] === null) {
                            return { success: false, error: `Path not found: ${path}` };
                        }
                        current = current[part];
                    }
                }

                if (typeof current !== 'object') {
                   return { success: false, error: `Path is not a directory: ${path}` };
                }
                
                return {
                    success: true,
                    data: Object.keys(current).map(key => ({
                        name: key,
                        isDirectory: typeof current[key] === 'object' && current[key] !== null,
                    })),
                };
            }

            read(path) {
                const resolved = this._resolvePath(path);
                if (!resolved || typeof resolved.parent[resolved.key] !== 'string') {
                    return { success: false, error: `File not found or is a directory: ${path}` };
                }
                return { success: true, data: resolved.parent[resolved.key] };
            }

            write(path, content, isUpdate = false) {
                const resolved = this._resolvePath(path, !isUpdate);
                 if (!resolved) {
                    return { success: false, error: `Invalid path: ${path}` };
                }

                if (resolved.parent[resolved.key] !== undefined && !isUpdate) {
                   return { success: false, error: `File already exists: ${path}` };
                }
                if (resolved.parent[resolved.key] === undefined && isUpdate) {
                    return { success: false, error: `File does not exist: ${path}` };
                }

                resolved.parent[resolved.key] = content;
                this.saveToLocalStorage();
                return { success: true, data: `File ${isUpdate ? 'updated' : 'created'} successfully: ${path}` };
            }
        }
        const fs = new FileSystem();
        
        // --- GEMINI SERVICE ---
        // We'll define the service inline for now to avoid async import issues
        const useGemini = (isLocalMode, setFileSystemState) => {
            const [ai, setAi] = useState(null);
            useEffect(() => {
                try {
                    if (window.GoogleGenAI) {
                        const genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || "YOUR_API_KEY_HERE" });
                        setAi(genAI);
                    }
                } catch (e) {
                    console.error("Error initializing Gemini API. Make sure API key is set.", e);
                }
            }, []);

            const generateContent = async (prompt, existingHistory, onLog) => {
                if (!ai) {
                    onLog({ type: 'error', content: 'Gemini API not initialized.' });
                    return { responseText: "Gemini API not initialized.", newHistory: existingHistory };
                }

                const model = "gemini-2.5-flash";
                const systemInstruction = `You are an expert AI coding assistant.
- You work with the user's local filesystem through a virtual mirror system.
- IMPORTANT: When creating or updating files, ALWAYS use write_local_file to ensure files are actually saved to the local filesystem.
- Use read_file, list_files for reading operations.
- Use write_local_file for creating new files or updating existing files.
- Use create_local_directory for creating directories.
- Use delete_local_file for deleting files.
- Think step-by-step. For example, if asked to create a new component and use it, first create the file with write_local_file, then read the main app file, then update the main app file to import and use the new component.
- Always inform the user of the actions you have taken.
- When writing files, use relative paths from the opened directory root.
- Be careful with file operations - always check if files exist before modifying them.
- All changes are automatically tracked and synced to the local filesystem.`;

                const tools = [{
                    functionDeclarations: [
                        { name: "list_files", description: "List files and directories at a given path.", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "The directory path to list. Use '/' for root." } }, required: ["path"] } },
                        { name: "read_file", description: "Read the content of a file.", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "The path of the file to read." } }, required: ["path"] } },
                        { name: "create_file", description: "DEPRECATED: Use write_local_file instead. Create a new file with content (virtual only).", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "The full path for the new file (e.g., 'src/components/New.tsx')." }, content: { type: GeminiType.STRING, description: "The content to write into the file." } }, required: ["path", "content"] } },
                        { name: "update_file", description: "DEPRECATED: Use write_local_file instead. Update an existing file with new content (virtual only).", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "The path of the file to update." }, content: { type: GeminiType.STRING, description: "The new content to overwrite the file with." } }, required: ["path", "content"] } },
                        { name: "write_local_file", description: "Write content to a local file in the opened directory.", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "The relative path of the file to write (e.g., 'src/components/Button.tsx')." }, content: { type: GeminiType.STRING, description: "The content to write into the file." } }, required: ["path", "content"] } },
                        { name: "create_local_directory", description: "Create a new directory in the opened local directory.", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "The relative path of the directory to create (e.g., 'src/components')." } }, required: ["path"] } },
                        { name: "delete_local_file", description: "Delete a file from the opened local directory.", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "The relative path of the file to delete." } }, required: ["path"] } },
                        { name: "read_text_file", description: "Read complete contents of a file as text with optional head/tail lines.", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "The path of the file to read." }, head: { type: GeminiType.NUMBER, description: "First N lines to read (optional)." }, tail: { type: GeminiType.NUMBER, description: "Last N lines to read (optional)." } }, required: ["path"] } },
                        { name: "search_files", description: "Recursively search for files/directories that match patterns.", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "Starting directory path." }, pattern: { type: GeminiType.STRING, description: "Search pattern (glob-style)." }, excludePatterns: { type: GeminiType.ARRAY, description: "Exclude patterns (array of strings).", items: { type: GeminiType.STRING } } }, required: ["path", "pattern"] } },
                        { name: "move_file", description: "Move or rename files and directories.", parameters: { type: GeminiType.OBJECT, properties: { source: { type: GeminiType.STRING, description: "Source file/directory path." }, destination: { type: GeminiType.STRING, description: "Destination path." } }, required: ["source", "destination"] } },
                        { name: "get_file_info", description: "Get detailed file/directory metadata including size, dates, and permissions.", parameters: { type: GeminiType.OBJECT, properties: { path: { type: GeminiType.STRING, description: "Path to the file or directory." } }, required: ["path"] } },
                    ]
                }];
                
                const history = [...existingHistory, { role: "user", parts: [{ text: prompt }] }];

                try {
                    for (let i = 0; i < 15; i++) { // Safety break after 15 tool calls
                        const result = await ai.models.generateContent({
                            model,
                            contents: history,
                            config: { systemInstruction, tools }
                        });

                        if (!result.candidates || result.candidates.length === 0) {
                            onLog({ type: 'error', content: 'No response from AI.' });
                            return { responseText: "Sorry, I couldn't generate a response.", newHistory: history };
                        }
                        
                        const response = result;
                        const content = response.candidates[0].content;
                        history.push(content);

                        const functionCall = content.parts.find(p => p.functionCall)?.functionCall;

                        if (!functionCall) {
                            const responseText = response.text || "Completed actions using tools. Check the file system for changes.";
                            return { responseText, newHistory: history };
                        }

                        onLog({ type: 'tool', content: `Using tool: ${functionCall.name}(${JSON.stringify(functionCall.args)})` });

                        let toolResult;
                        const { name: functionName, args } = functionCall;

                        if (functionName === 'list_files') {
                            // Always use virtual mirror when local directory is open
                            const virtualStructure = virtualMirror.getVirtualStructure();
                            toolResult = { success: true, data: Object.keys(virtualStructure).map(key => ({
                                name: key,
                                isDirectory: typeof virtualStructure[key] === 'object' && virtualStructure[key] !== null,
                            })) };
                        } else if (functionName === 'read_file') {
                            // Always read from virtual mirror
                            const content = virtualMirror.getVirtualFile(args.path);
                            if (content !== null) {
                                toolResult = { success: true, data: content };
                            } else {
                                toolResult = { success: false, error: `File not found: ${args.path}` };
                            }
                        } else if (functionName === 'create_file') {
                            // Always create in virtual mirror
                            virtualMirror.setVirtualFile(args.path, args.content);
                            // Update the file system state to reflect changes
                            setFileSystemState(virtualMirror.getVirtualStructure());
                            toolResult = { success: true, message: `File created: ${args.path}` };
                        } else if (functionName === 'update_file') {
                            // Always update in virtual mirror
                            virtualMirror.setVirtualFile(args.path, args.content);
                            // Update the file system state to reflect changes
                            setFileSystemState(virtualMirror.getVirtualStructure());
                            toolResult = { success: true, message: `File updated: ${args.path}` };
                        } else if (functionName === 'write_local_file') {
                            // Write to local filesystem
                            const result = await localFS.writeFile(args.path, args.content);
                            toolResult = result;
                        } else if (functionName === 'create_local_directory') {
                            // Create directory in local filesystem
                            const result = await localFS.createDirectory(args.path);
                            toolResult = result;
                        } else if (functionName === 'delete_local_file') {
                            // Delete file from local filesystem
                            const result = await localFS.deleteFile(args.path);
                            toolResult = result;
                        } else if (functionName === 'read_text_file') {
                            // Read file with optional head/tail lines
                            const content = virtualMirror.getVirtualFile(args.path);
                            if (content !== null) {
                                let lines = content.split('\n');
                                if (args.head) {
                                    lines = lines.slice(0, args.head);
                                } else if (args.tail) {
                                    lines = lines.slice(-args.tail);
                                }
                                toolResult = { success: true, data: lines.join('\n') };
                            } else {
                                toolResult = { success: false, error: `File not found: ${args.path}` };
                            }
                        } else if (functionName === 'search_files') {
                            // Search for files matching pattern
                            const virtualStructure = virtualMirror.getVirtualStructure();
                            const matches = [];
                            const searchInStructure = (obj, currentPath = '') => {
                                for (const [name, content] of Object.entries(obj)) {
                                    const fullPath = currentPath ? `${currentPath}/${name}` : name;
                                    if (typeof content === 'object' && content !== null) {
                                        // Directory
                                        searchInStructure(content, fullPath);
                                    } else {
                                        // File - check if matches pattern
                                        if (name.includes(args.pattern) || fullPath.includes(args.pattern)) {
                                            matches.push(fullPath);
                                        }
                                    }
                                }
                            };
                            searchInStructure(virtualStructure);
                            toolResult = { success: true, data: matches };
                        } else if (functionName === 'move_file') {
                            // Move/rename file
                            const content = virtualMirror.getVirtualFile(args.source);
                            if (content !== null) {
                                // Remove from source
                                virtualMirror.setVirtualFile(args.source, null);
                                // Add to destination
                                virtualMirror.setVirtualFile(args.destination, content);
                                setFileSystemState(virtualMirror.getVirtualStructure());
                                toolResult = { success: true, message: `File moved from ${args.source} to ${args.destination}` };
                            } else {
                                toolResult = { success: false, error: `Source file not found: ${args.source}` };
                            }
                        } else if (functionName === 'get_file_info') {
                            // Get file metadata
                            const content = virtualMirror.getVirtualFile(args.path);
                            if (content !== null) {
                                toolResult = { 
                                    success: true, 
                                    data: {
                                        path: args.path,
                                        size: content.length,
                                        type: 'file',
                                        exists: true
                                    }
                                };
                            } else {
                                toolResult = { success: false, error: `File not found: ${args.path}` };
                            }
                        } else {
                            toolResult = { success: false, error: `Unknown tool: ${functionName}`};
                        }

                        onLog({ type: 'system', content: `Tool Result: ${JSON.stringify(toolResult)}` });
                        
                        history.push({
                            role: 'tool',
                            parts: [{ functionResponse: { name: functionName, response: toolResult } }]
                        });
                    }
                   
                    const responseText = "Tool interaction ended. If something is incomplete, ask me to continue.";
                    return { responseText, newHistory: history };

                } catch (error) {
                    console.error("Error generating content:", error);
                    onLog({ type: 'error', content: `An error occurred: ${error.message}` });
                    return { responseText: `An error occurred: ${error.message}`, newHistory: existingHistory };
                }
            };
            return { generateContent };
        };

        // --- COMPONENTS ---

        const FileExplorer = ({ onFileSelect, fileTree, onReset, onRefresh, onOpenLocalDirectory, isLocalMode, onSyncFromLocal, onSyncToLocal, activePath, rootName }) => {
            const [tree, setTree] = useState(fileTree);
            const [filter, setFilter] = useState('');
            const [expanded, setExpanded] = useState(new Set());
            useEffect(() => setTree(fileTree), [fileTree]);

            const toggleExpand = (path) => {
                const next = new Set(expanded);
                if (next.has(path)) next.delete(path); else next.add(path);
                setExpanded(next);
            };
            const expandAll = () => {
                const collect = (node, path = '', acc = new Set()) => {
                    Object.entries(node).forEach(([name, content]) => {
                        const p = path ? `${path}/${name}` : name;
                        if (typeof content === 'object' && content !== null) {
                            acc.add(p);
                            collect(content, p, acc);
                        }
                    });
                    return acc;
                };
                setExpanded(collect(tree));
            };
            const collapseAll = () => setExpanded(new Set());

            const matchFilter = (name) => !filter || name.toLowerCase().includes(filter.toLowerCase());

            const renderTree = (node, path) => {
                return Object.entries(node).map(([name, content]) => {
                    const currentPath = path ? `${path}/${name}` : name;
                    const isDirectory = typeof content === 'object' && content !== null;
                    const depth = currentPath ? currentPath.split('/').length - 1 : 0;
                    
                    if (isDirectory) {
                        // If none of the children match filter, hide folder (unless name matches)
                        const hasMatch = (obj) => {
                            return Object.entries(obj).some(([n, c]) => {
                                const cp = `${currentPath}/${n}`;
                                if (typeof c === 'object' && c !== null) return hasMatch(c) || matchFilter(n);
                                return matchFilter(n);
                            });
                        };
                        if (!matchFilter(name) && !hasMatch(content)) return null;
                        const isOpen = expanded.has(currentPath);
                        return (
                           <div key={currentPath}>
                               <div className="cursor-pointer hover:text-cyan-400 flex items-center" style={{ paddingLeft: depth * 12 }} onClick={() => toggleExpand(currentPath)}>
                                   <span className="mr-1">{isOpen ? '📂' : '📁'}</span>
                                   <span>{name}</span>
                               </div>
                               {isOpen && (
                                   <div>
                               {renderTree(content, currentPath)}
                                   </div>
                               )}
                           </div>
                        );
                    }
                    if (!matchFilter(name)) return null;
                    const isActive = activePath === currentPath;
                    return (
                        <div key={currentPath} className={`cursor-pointer flex items-center hover:text-cyan-400 ${isActive ? 'text-cyan-400' : ''}`} style={{ paddingLeft: depth * 12 + 16 }} onClick={() => onFileSelect(currentPath)}>
                            <span className="mr-1">📄</span>
                            <span>{name}</span>
                        </div>
                    );
                });
            };
            
            const breadcrumb = () => {
                if (!activePath) return '—';
                const parts = activePath.split('/');
                return parts.map((p, i) => (
                    <span key={i} className="text-xs text-gray-400">
                        {i > 0 && <span className="mx-1">/</span>}
                        <span>{p}</span>
                    </span>
                ));
            };
            
            return (
                 <div className="bg-[#010409] h-full flex flex-col">
                    <div className="p-2 border-b border-gray-800 text-sm font-bold flex justify-between items-center">
                        <span>EXPLORER <span className="ml-2 font-normal text-gray-400">{rootName || 'Workspace'}</span></span>
                         <div className="flex items-center gap-1">
                            <button onClick={onOpenLocalDirectory} className="mr-2 px-1 rounded hover:bg-gray-700" title="Open Local Directory">📁</button>
                            {isLocalMode && (
                                <>
                                    <button onClick={onSyncFromLocal} className="mr-2 px-1 rounded hover:bg-gray-700" title="Sync From Local">⬇️</button>
                                    <button onClick={onSyncToLocal} className="mr-2 px-1 rounded hover:bg-gray-700" title="Sync To Local">⬆️</button>
                                </>
                            )}
                            <button onClick={onRefresh} className="mr-2 px-1 rounded hover:bg-gray-700" title="Refresh">🔄</button>
                            <button onClick={onReset} className="px-1 rounded hover:bg-gray-700" title="Reset Filesystem">🗑️</button>
                        </div>
                    </div>
                    <div className="p-2 border-b border-gray-800 flex items-center gap-2">
                        <input value={filter} onChange={(e) => setFilter(e.target.value)} placeholder="Filter files..." className="w-full bg-[#0D1117] border border-gray-700 rounded p-1 text-xs focus:outline-none focus:border-cyan-400" />
                        <button onClick={expandAll} className="px-1 rounded hover:bg-gray-700 text-xs" title="Expand all">➕</button>
                        <button onClick={collapseAll} className="px-1 rounded hover:bg-gray-700 text-xs" title="Collapse all">➖</button>
                    </div>
                    {isLocalMode && (
                        <div className="p-2 text-xs text-green-400 border-b border-gray-800 bg-green-900/20">
                            📁 Local directory loaded
                        </div>
                    )}
                    <div className="px-2 py-1 text-xs text-gray-400 border-b border-gray-800 truncate">{breadcrumb()}</div>
                    <div className="p-2 text-sm flex-grow overflow-y-auto">{renderTree(tree, '')}</div>
                </div>
            )
        };
        
        const Editor = ({ code, onCodeChange, language = 'javascript' }) => {
            const editorRef = useRef(null);
            const monacoRef = useRef(null);

            useEffect(() => {
                if (!editorRef.current) return;

                // Configure Monaco loader
                require.config({ 
                    paths: { 
                        'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs' 
                    } 
                });

                // Load Monaco Editor
                require(['vs/editor/editor.main'], function () {
                    if (monacoRef.current) {
                        monacoRef.current.dispose();
                    }

                    monacoRef.current = monaco.editor.create(editorRef.current, {
                        value: code || '',
                        language: language,
                        theme: 'vs-dark',
                        automaticLayout: true,
                        minimap: { enabled: false },
                        fontSize: 14,
                        lineNumbers: 'on',
                        roundedSelection: false,
                        scrollBeyondLastLine: false,
                        readOnly: false,
                        cursorStyle: 'line',
                        wordWrap: 'on',
                        folding: true,
                        lineDecorationsWidth: 10,
                        lineNumbersMinChars: 3,
                        renderLineHighlight: 'line',
                        selectOnLineNumbers: true,
                        glyphMargin: true,
                        contextmenu: true,
                        mouseWheelZoom: true,
                        smoothScrolling: true,
                        cursorBlinking: 'blink',
                        cursorSmoothCaretAnimation: true,
                        padding: { top: 16, bottom: 16 },
                        scrollbar: {
                            vertical: 'auto',
                            horizontal: 'auto',
                            useShadows: false,
                            verticalHasArrows: false,
                            horizontalHasArrows: false,
                            verticalScrollbarSize: 8,
                            horizontalScrollbarSize: 8
                        },
                        // Additional features
                        suggestOnTriggerCharacters: true,
                        acceptSuggestionOnEnter: 'on',
                        tabCompletion: 'on',
                        wordBasedSuggestions: 'matchingDocuments',
                        parameterHints: { enabled: true },
                        hover: { enabled: true },
                        lightbulb: { enabled: true },
                        codeLens: true,
                        formatOnPaste: true,
                        formatOnType: true,
                        bracketPairColorization: { enabled: true },
                        guides: {
                            bracketPairs: true,
                            indentation: true
                        },
                        // Keyboard shortcuts
                        multiCursorModifier: 'ctrlCmd',
                        accessibilitySupport: 'auto'
                    });

                    // Listen for content changes
                    monacoRef.current.onDidChangeModelContent(() => {
                        const newValue = monacoRef.current.getValue();
                        onCodeChange(newValue);
                    });
                });

                return () => {
                    if (monacoRef.current) {
                        monacoRef.current.dispose();
                    }
                };
            }, []);

            // Update editor content when code prop changes
            useEffect(() => {
                if (monacoRef.current && monacoRef.current.getValue() !== code) {
                    monacoRef.current.setValue(code || '');
                }
            }, [code]);

            // Update language when it changes
            useEffect(() => {
                if (monacoRef.current) {
                    const model = monacoRef.current.getModel();
                    if (model) {
                        monaco.editor.setModelLanguage(model, language);
                    }
                }
            }, [language]);

            return <div ref={editorRef} className="w-full h-full" />;
        };

            const Chatbox = ({ messages, onSendMessage, loading, onMemoryClear, onMemoryExport, onMemoryImport }) => {
            const [input, setInput] = useState('');
            const messagesEndRef = useRef(null);
            
            const handleSend = () => {
                if (!input.trim() || loading) return;
                onSendMessage(input.trim());
                    setInput('');
            };
            const handleImport = async () => {
                try {
                    const text = prompt('Paste memory snapshot JSON:');
                    if (text != null) onMemoryImport?.(text);
                } catch {}
            };
            
            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [messages]);

            return (
                <div className="bg-[#010409] h-full flex flex-col">
                    <div className="p-2 border-b border-gray-800 text-sm font-bold flex items-center justify-between">
                        <span>CHAT</span>
                        <div className="flex gap-2 text-xs">
                            <button className="px-2 py-1 bg-gray-800 rounded hover:bg-gray-700" onClick={onMemoryExport}>Export</button>
                            <button className="px-2 py-1 bg-gray-800 rounded hover:bg-gray-700" onClick={handleImport}>Import</button>
                            <button className="px-2 py-1 bg-red-700 rounded hover:bg-red-600" onClick={onMemoryClear}>Clear</button>
                        </div>
                    </div>
                    <div className="p-2 border-b border-gray-800 text-sm font-bold">MESSAGES</div>
                    <div className="flex-1 overflow-y-auto p-2 space-y-2">
                       {messages.map((msg, index) => (
                           <div key={index} className={`flex flex-col ${msg.role === 'user' ? 'items-end' : 'items-start'}`}>
                               <div className={`p-2 rounded-lg max-w-[80%] ${msg.role === 'user' ? 'bg-blue-800' : 'bg-gray-700'}`}>
                                    <pre className="whitespace-pre-wrap font-sans">{msg.content}</pre>
                               </div>
                           </div>
                       ))}
                    </div>
                    <div className="p-2 border-t border-gray-800 flex">
                        <input 
                            type="text"
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyPress={(e) => e.key === 'Enter' && !loading && handleSend()}
                            className="flex-grow bg-[#0D1117] border border-gray-700 rounded-l-md p-2 focus:outline-none focus:border-cyan-400 text-sm"
                            placeholder="Ask the AI to do something..."
                            disabled={loading}
                        />
                        <button onClick={handleSend} disabled={loading} className="bg-cyan-600 text-white p-2 rounded-r-md hover:bg-cyan-500 disabled:bg-gray-600">
                            Send
                        </button>
                    </div>
                </div>
            )
        };

        const Logger = ({ logs }) => {
            const logsEndRef = useRef(null);
            useEffect(() => {
                logsEndRef.current?.scrollIntoView({ behavior: "smooth" });
            }, [logs]);

            const getColor = (type) => {
                if (type === 'error') return 'text-red-500';
                if (type === 'tool') return 'text-yellow-400';
                if (type === 'system') return 'text-purple-400';
                return 'text-gray-400';
            };
            
            return (
                <div className="bg-[#010409] h-full flex flex-col">
                    <div className="p-2 border-b border-gray-800 text-sm font-bold">LOGS</div>
                    <div className="flex-grow p-2 overflow-y-auto text-xs font-mono">
                        {logs.map((log, index) => (
                            <div key={index} className={getColor(log.type)}>
                                <span className="font-bold mr-2">[{new Date().toLocaleTimeString()}]</span>
                                <span>{log.content}</span>
                            </div>
                        ))}
                        <div ref={logsEndRef} />
                    </div>
                </div>
            );
        };

        const MemoryInspector = ({ getStats }) => {
            const [stats, setStats] = useState(getStats());
            const refresh = () => setStats(getStats());
            const copySnap = () => {
                try { navigator.clipboard?.writeText(stats.snapshot); } catch {}
            };
            return (
                <div className="bg-[#010409] h-full flex flex-col">
                    <div className="p-2 border-b border-gray-800 text-sm font-bold flex justify-between items-center">
                        <span>MEMORY</span>
                        <div className="flex gap-2 text-xs">
                            <button className="px-2 py-1 bg-gray-800 rounded hover:bg-gray-700" onClick={refresh}>Refresh</button>
                            <button className="px-2 py-1 bg-gray-800 rounded hover:bg-gray-700" onClick={copySnap}>Copy</button>
                        </div>
                    </div>
                    <div className="p-2 text-xs space-y-1">
                        <div>Messages: <span className="text-gray-300">{stats.messages}</span></div>
                        <div>Facts: <span className="text-gray-300">{stats.facts}</span></div>
                        <div>Vectors: <span className="text-gray-300">{stats.vectors}</span></div>
                        <div>Static blocks: <span className="text-gray-300">{stats.staticBlocks}</span></div>
                    </div>
                    <div className="p-2 border-t border-gray-800 text-xs font-mono overflow-y-auto flex-1">
                        <div className="mb-1 font-bold">Preview:</div>
                        {(stats.preview || []).map((p, i) => (
                            <div key={i} className="mb-2">
                                <div className="text-gray-400">{p.role}</div>
                                <pre className="whitespace-pre-wrap break-words">{p.text}</pre>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- MAIN APP ---
        const App = () => {
            const [loading, setLoading] = useState(false);
            const [fileSystemState, setFileSystemState] = useState(fs.fs);
            const [tabs, setTabs] = useState([]);
            const [activeTab, setActiveTab] = useState(null);
            const [code, setCode] = useState('');
            const [currentLanguage, setCurrentLanguage] = useState('javascript');
            const [messages, setMessages] = useState([{role: 'ai', content: 'Hello! How can I help you code today?'}]);
            const [logs, setLogs] = useState([]);
            const [isLocalMode, setIsLocalMode] = useState(false);
            const { generateContent } = useGemini(isLocalMode, setFileSystemState);
            const memoryRef = useRef(new LIMemory({ tokenLimit: 12000, staticBlocks: [
                'You are an expert coding assistant. Prefer creating files with write_local_file so they persist to disk.'
            ], maxFacts: 50, enableVector: true }));

            // Load memory from localStorage on mount
            useEffect(() => {
                try {
                    const snap = localStorage.getItem('ai_memory_snapshot');
                    if (snap) memoryRef.current.load(snap);
                } catch {}
            }, []);

            // Language detection based on file extension
            const getLanguageFromFile = (filename) => {
                if (!filename) return 'javascript';
                const ext = filename.split('.').pop().toLowerCase();
                const languageMap = {
                    'js': 'javascript',
                    'jsx': 'javascript',
                    'ts': 'typescript',
                    'tsx': 'typescript',
                    'py': 'python',
                    'java': 'java',
                    'cpp': 'cpp',
                    'c': 'c',
                    'cs': 'csharp',
                    'php': 'php',
                    'rb': 'ruby',
                    'go': 'go',
                    'rs': 'rust',
                    'html': 'html',
                    'css': 'css',
                    'scss': 'scss',
                    'sass': 'sass',
                    'less': 'less',
                    'json': 'json',
                    'xml': 'xml',
                    'yaml': 'yaml',
                    'yml': 'yaml',
                    'md': 'markdown',
                    'sql': 'sql',
                    'sh': 'shell',
                    'bash': 'shell',
                    'zsh': 'shell',
                    'fish': 'shell',
                    'ps1': 'powershell',
                    'dockerfile': 'dockerfile',
                    'yml': 'yaml',
                    'yaml': 'yaml'
                };
                return languageMap[ext] || 'javascript';
            };

            const refreshFileSystem = useCallback(async () => {
                if (isLocalMode && localFS.directoryHandle) {
                    // Refresh local directory structure
                    const result = await localFS.loadDirectoryStructure();
                    if (result.success) {
                        virtualMirror.createMirror(result.data);
                        setFileSystemState(virtualMirror.getVirtualStructure());
                        handleLog({type: 'system', content: 'Local directory refreshed'});
                    } else {
                        handleLog({type: 'error', content: `Failed to refresh local directory: ${result.message}`});
                    }
                } else {
                    // Fallback to virtual filesystem
              setFileSystemState({...fs.fs});
                }
            }, [isLocalMode, handleLog]);

            const handleLog = useCallback((log) => {
                setLogs(prev => [...prev, log]);
            }, []);

            // Auto-restore local directory on page load
            useEffect(() => {
                const restoreLocalDirectory = async () => {
                    try {
                        const lastHandle = await loadHandle();
                        if (lastHandle) {
                            // Restore the directory handle
                            localFS.directoryHandle = lastHandle;
                            localFS.isLocalMode = true;
                            setIsLocalMode(true);
                            
                            // Load the directory structure
                            const result = await localFS.loadDirectoryStructure();
                            if (result.success) {
                                // Create virtual mirror from the loaded structure
                                virtualMirror.createMirror(result.data);
                                setFileSystemState(virtualMirror.getVirtualStructure());
                                handleLog({type: 'system', content: `Restored local directory: ${lastHandle.name}`});
                            }
                        }
                    } catch (error) {
                        handleLog({type: 'error', content: `Failed to restore local directory: ${error.message}`});
                    }
                };
                
                restoreLocalDirectory();
            }, [handleLog]);

            const handleFileSelect = useCallback(async (path) => {
                if (!tabs.includes(path)) {
                    setTabs(prev => [...prev, path]);
                }
                setActiveTab(path);
                
                // Set language based on file extension
                const language = getLanguageFromFile(path);
                setCurrentLanguage(language);
                
                // Always work with virtual mirror (which mirrors the local filesystem)
                const virtualContent = virtualMirror.getVirtualFile(path);
                if (virtualContent !== null) {
                    setCode(virtualContent);
                    handleLog({type: 'system', content: `File loaded: ${path} (${language})`});
                } else {
                    // Fall back to reading from local file system and update mirror
                    const fileContent = await localFS.readFile(path);
                if(fileContent.success) {
                    setCode(fileContent.data);
                        // Update virtual mirror with local content
                        virtualMirror.setVirtualFile(path, fileContent.data);
                        handleLog({type: 'system', content: `File loaded from local: ${path} (${language})`});
                } else {
                        handleLog({type: 'error', content: `Error reading file: ${fileContent.message}`});
                }
                }
            }, [tabs, handleLog, isLocalMode, getLanguageFromFile]);
            
            const handleCloseTab = (path) => {
                const newTabs = tabs.filter(t => t !== path);
                setTabs(newTabs);
                if (activeTab === path) {
                    if (newTabs.length > 0) {
                        handleFileSelect(newTabs[0]);
                    } else {
                        setActiveTab(null);
                        setCode('');
                    }
                }
            };
            
            const handleCodeChange = (newCode) => {
                setCode(newCode);
                if(activeTab) {
                    // Always update virtual mirror with changes
                    virtualMirror.setVirtualFile(activeTab, newCode);
                }
            };

            const handleResetFileSystem = () => {
                if (window.confirm("Are you sure you want to reset the file system? All changes will be lost.")) {
                    localFS.reset();
                    virtualMirror.reset();
                    fs.reset();
                    refreshFileSystem();
                    setIsLocalMode(false);
                    setTabs([]);
                    setActiveTab(null);
                    setCode('');
                    memoryRef.current.clear(); // Also reset conversation history
                    setMessages([{role: 'ai', content: 'Hello! How can I help you code today?'}]);
                    handleLog({type: 'system', content: 'File system has been reset.'});
                }
            };

            const handleOpenLocalDirectory = useCallback(async () => {
                const result = await localFS.openDirectory();
                if (result.success) {
                    const structureResult = await localFS.loadDirectoryStructure();
                    if (structureResult.success) {
                        // Create virtual mirror of the local directory
                        const mirrorResult = await virtualMirror.createMirror(structureResult.data);
                        if (mirrorResult.success) {
                            setFileSystemState(structureResult.data);
                            setIsLocalMode(true);
                            handleLog({type: 'system', content: `${result.message} - Virtual mirror created`});
                        } else {
                            handleLog({type: 'error', content: 'Failed to create virtual mirror'});
                        }
                    } else {
                        handleLog({type: 'error', content: structureResult.message});
                    }
                } else {
                    handleLog({type: 'error', content: result.message});
                }
            }, [handleLog]);

            const handleSaveFile = useCallback(async () => {
                if (activeTab && code) {
                    if (isLocalMode && localFS.isLocalFile(activeTab)) {
                        // Update virtual mirror first
                        virtualMirror.setVirtualFile(activeTab, code);
                        // Then sync to local
                        const syncResult = await virtualMirror.syncToLocal();
                        if (syncResult.success) {
                            handleLog({type: 'system', content: `File saved to local: ${activeTab}`});
                        } else {
                            handleLog({type: 'error', content: `Failed to sync to local: ${syncResult.message}`});
                        }
                    } else {
                        fs.write(activeTab, code, true);
                        handleLog({type: 'system', content: `File saved: ${activeTab}`});
                    }
                }
            }, [activeTab, code, isLocalMode, handleLog]);

            const handleSyncFromLocal = useCallback(async () => {
                if (isLocalMode) {
                    const syncResult = await virtualMirror.syncFromLocal();
                    if (syncResult.success) {
                        setFileSystemState(virtualMirror.getVirtualStructure());
                        handleLog({type: 'system', content: 'Synced from local to virtual'});
                    } else {
                        handleLog({type: 'error', content: `Sync failed: ${syncResult.message}`});
                    }
                }
            }, [isLocalMode, handleLog]);

            const handleSyncToLocal = useCallback(async () => {
                if (isLocalMode) {
                    const syncResult = await virtualMirror.syncToLocal();
                    if (syncResult.success) {
                        handleLog({type: 'system', content: `Synced ${syncResult.changes.length} files to local`});
                    } else {
                        handleLog({type: 'error', content: `Sync failed: ${syncResult.message}`});
                    }
                }
            }, [isLocalMode, handleLog]);
            
            const handleSendMessage = useCallback(async (prompt) => {
                setMessages(prev => [...prev, {role: 'user', content: prompt}]);
                setLoading(true);
                handleLog({type: 'info', content: `User prompt: "${prompt}"`});

                // Add user message to memory, build trimmed history
                memoryRef.current.add({ role: 'user', content: prompt });
                const trimmedHistory = memoryRef.current.getLLM();
                const { responseText } = await generateContent(prompt, trimmedHistory, handleLog);
                
                if(responseText) {
                    setMessages(prev => [...prev, {role: 'ai', content: responseText}]);
                    memoryRef.current.add({ role: 'assistant', content: responseText });
                    try { localStorage.setItem('ai_memory_snapshot', memoryRef.current.snapshot()); } catch {}
                }
                
                setLoading(false);
                refreshFileSystem(); // Refresh FS view after AI operations
            }, [generateContent, handleLog, refreshFileSystem]);

            // Memory menu handlers
            const handleMemoryClear = useCallback(() => {
                memoryRef.current.clear();
                try { localStorage.removeItem('ai_memory_snapshot'); } catch {}
                handleLog({ type: 'system', content: 'Memory cleared.' });
            }, [handleLog]);
            const handleMemoryExport = useCallback(() => {
                try {
                    const snap = memoryRef.current.snapshot();
                    navigator.clipboard?.writeText(snap).then(() => {
                        handleLog({ type: 'system', content: 'Memory snapshot copied to clipboard.' });
                    }).catch(() => {
                        // fallback prompt
                        prompt('Copy memory snapshot JSON:', snap);
                    });
                } catch (e) {
                    handleLog({ type: 'error', content: `Failed to export memory: ${e?.message || e}` });
                }
            }, [handleLog]);
            const handleMemoryImport = useCallback((text) => {
                try {
                    memoryRef.current.load(text);
                    localStorage.setItem('ai_memory_snapshot', memoryRef.current.snapshot());
                    handleLog({ type: 'system', content: 'Memory snapshot imported.' });
                } catch (e) {
                    handleLog({ type: 'error', content: `Failed to import memory: ${e?.message || e}` });
                }
            }, [handleLog]);

            const getMemoryStats = useCallback(() => {
                const mem = memoryRef.current;
                const previewMsgs = (mem.getLLM() || []).slice(-5).map(m => ({
                    role: m.role,
                    text: (m.parts?.map(p => p.text || '').join('') || '').slice(0, 300)
                }));
                return {
                    messages: (mem.messages || []).length,
                    facts: (mem.facts || []).length,
                    vectors: (mem.vectorDocs || []).length,
                    staticBlocks: (mem.staticBlocks || []).length,
                    preview: previewMsgs,
                    snapshot: mem.snapshot()
                };
            }, []);

            return (
                <Fragment>
                    <div className="h-screen w-screen flex flex-col text-sm">
                        {/* Main Content */}
                        <div className="flex flex-grow overflow-hidden">
                            {/* Left Panel */}
                            <div className="w-1/5 min-w-[200px] border-r border-gray-800">
                                <FileExplorer 
                                    onFileSelect={handleFileSelect} 
                                    fileTree={fileSystemState} 
                                    onReset={handleResetFileSystem} 
                                    onRefresh={refreshFileSystem}
                                    onOpenLocalDirectory={handleOpenLocalDirectory}
                                    isLocalMode={isLocalMode}
                                    onSyncFromLocal={handleSyncFromLocal}
                                    onSyncToLocal={handleSyncToLocal}
                                    activePath={activeTab}
                                    rootName={isLocalMode && localFS.directoryHandle ? localFS.directoryHandle.name : 'Workspace'}
                                />
                            </div>

                            {/* Center Panel */}
                            <div className="w-3/5 flex flex-col">
                                {/* Tabs */}
                                {tabs.length > 0 && (
                                    <div className="flex border-b border-gray-800 bg-[#010409]">
                                    {tabs.map(tab => (
                                        <div key={tab} className={`py-2 px-4 cursor-pointer text-xs ${activeTab === tab ? 'bg-[#0D1117] border-b-2 border-cyan-400' : 'text-gray-400'}`}
                                            onClick={() => handleFileSelect(tab)}>
                                            {tab.split('/').pop()}
                                            <button className="ml-2 hover:text-white" onClick={(e) => { e.stopPropagation(); handleCloseTab(tab); }}>x</button>
                                        </div>
                                    ))}
                                    </div>
                                )}
                                {/* Editor */}
                                <div className="flex-grow">
                                    <Editor 
                                        code={code} 
                                        onCodeChange={handleCodeChange} 
                                        language={currentLanguage}
                                    />
                                </div>
                            </div>
                            
                            {/* Right Panel */}
                            <div className="w-1/5 min-w-[250px] border-l border-gray-800">
                                <Chatbox 
                                    messages={messages} 
                                    onSendMessage={handleSendMessage} 
                                    loading={loading}
                                    onMemoryClear={handleMemoryClear}
                                    onMemoryExport={handleMemoryExport}
                                    onMemoryImport={handleMemoryImport}
                                />
                            </div>
                        </div>

                        {/* Bottom Panel */}
                        <div className="h-1/4 min-h-[150px] border-t border-gray-800 flex">
                            <div className="flex-1 min-w-0">
                                <Logger logs={logs} />
                            </div>
                            <div className="w-1/3 min-w-[260px] border-l border-gray-800">
                                <MemoryInspector getStats={getMemoryStats} />
                            </div>
                        </div>
                    </div>
                </Fragment>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<StrictMode><App /></StrictMode>);
    </script>
</body>
</html>